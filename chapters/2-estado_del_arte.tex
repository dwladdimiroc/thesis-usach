\chapter{Estado del arte}
\label{cap:estado_del_arte}

Dentro de la literatura se han encontrado distintas perspectivas al problema de balance de carga en un SPS (Sistema de Procesamiento de \textsl{Streaming}). Una perspectiva es respecto a los recursos físicos, donde se define la sobrecarga de un nodo por la cantidad de operadores que posee \cite{MadsenTZ14}. Una solución es lo realizado por Borealis; éste realiza un balanceador según la carga de los nodos \cite{XingZH05}, de tal manera de enviar las tareas a los nodos menos sobrecargados. Otra perspectiva es a nivel lógico, la cual está orientada en el grafo de operadores, donde el problema está en la sobrecarga de un operador \cite{FernandezMKP13}. Este problema se debe a que un operador puede sobrecargarse, formando cuellos de botella y  esperas en el sistema. Una de las soluciones, es lo presentando por Schneider que corresponde a la paralelización de una tarea que posea distintos operadores \cite{SchneiderAGBW09}, de tal manera que cada tarea pueda trabajar de forma independiente y no sobrecargar un nodo. Otra solución es lo presentando por Fernández \cite{FernandezMKP13}, el cual consiste en la replicación de un operador según la sobrecarga de algún operador en el grafo, de tal manera de detectarlo y crear una réplica de éste para que puedan ambos operadores trabajar en conjunto para la operación demandada.

Por lo tanto, para realizar optimizaciones al sistema se han presentando dos tipos de enfoques: el estático y el dinámico \cite{Dong06schedulingalgorithms}. El primer enfoque se centra en la confección de un modelo definido y fijo antes de iniciar el sistema y que no varía en el tiempo. En cambio, el segundo se basa en la adaptación del sistema según su estado en tiempo de ejecución.

\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}
\section{Enfoque estático}

Este enfoque se ha implementando en distintos motores de \textsl{streaming}, donde no se depende del estado del sistema \cite{stormtwitter, s4}. De esta manera, no existe una interrupción en la ejecución o un cambio en las variables  \cite{CasavantK88}. Esto significa, que al momento de distribuir los distintos operadores, esto se realiza homogéneamente, independiente de la carga, latencia u otro estado del sistema.

\textsl{Storm} utiliza la técnica de distribución de operadores según alguna política, tomando el enfoque estático \cite{stormtwitter}. El sistema configura el número de operadores que son necesarios para realizar una tarea, para que después estos sean repartidos en los distintos nodos disponibles según la política de \textit{Shuffle grouping}. Esta técnica basada en algoritmos de planificación \cite{bookScheduling}, consiste en distribuir los operadores en los distintos nodos utilizando una planificación \textsl{Round-Robin}, de tal manera que la cantidad de operadores sea uniforme en los nodos del sistema \cite{bookstorm}.

Otra técnica es el uso de la función \textsl{hash} \cite{RogawayS04} para distribuir los operadores en el grafo, como lo planteado en S4 \cite{s4yahoo}. Esto consiste en aplicar lo anterior a algún atributo del evento, mapeando el evento al operador que corresponda de los $n$ operadores disponibles según el valor de la función. Cabe destacar que si no existe un operador mapeado con la imagen de la función, el sistema clona uno existente evaluando el nuevo con la imagen de la función como identificador. De esta manera, esta técnica provee dinamicidad respecto a la cantidad de operadores en el sistema.

Una ventaja del enfoque estático es el bajo costo de la implementación de los métodos, lo cual es beneficioso para sistemas con bajos recursos. Por otra parte, una desventaja existente es la sobrecarga de un nodo u operador, debido que no asegura que alguno de ellos tenga una mayor tasa de procesamiento que la tasa de llegada. Si bien, no es una solución óptima, es un buen complemento para un modelo con el enfoque dinámico.

\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}
\section{Enfoque dinámico}

Este enfoque está basado en el estado del sistema, donde según las variables y estado de cada uno de sus atributos, genera una acción en el sistema \cite{CasavantK88}. Esto significa que si el sistema posee alguna anomalía, como una sobrecarga en un operador o latencia entre distintos nodos, se realiza un cambio en el sistema, con el fin de solucionar estos problemas. Para poder dar una solución al problema de sobrecarga, se pueden utilizar dos tipos de modelos: reactivo y predictivo.

\subsection{Reactivo}

Este modelo está basado en la detección de sobrecargas en el sistema a través de un monitor \cite{GulisanoJPSV12}. El monitor recibe periódicamente la carga de cada uno de los nodos u operadores, y en caso que se sobrepase un umbral, se aplica una técnica para aumentar el rendimiento bajo una métrica dada. El umbral puede estar basado en el tiempo de procesamiento, el tamaño de la cola u otra variable del nodo u operador \cite{BhuvanagiriGKS06}. Por ejemplo, para realizar una paralelización de un operador sobrecargado, se utiliza un algoritmo que analiza si los operadores sobrepasan un umbral propuesta, el cual está determinado por la frecuencia máxima de llegada de ellos según el tasa de procesamiento del operador \cite{SchneiderAGBW09}.

\subsection{Predictivo}
El modelo predictivo está basado en modelos matemáticos que puedan simular la actividad del operador, y predecir la carga de éste. Primero se determina la carga de un operador en cierto período de tiempo, y después se aplica un modelo matemático que predice la carga en el próximo intervalo de tiempo. La predicción de carga de cada operador se realiza mediante modelos de Markov \cite{GongGW10}, y analizando si existe alguna sobrecarga en los operadores a futuro. Si bien lo anterior no ha sido implementando en el contexto de \textsl{Stream}, si se ha realizado en \textsl{Cloud Computing} según la sobrecarga de los computadores \cite{NguyenSGSW13}.\\

Existen distintas técnicas que son utilizadas en ambos modelos, entre las cuales están la planificación determinista \cite{XuCTS14, DongTS07}, descarte de eventos \cite{SheuC09}, migración \cite{XingZH05}, para\-lelización \cite{GulisanoJPSV12, IshiiS11, GedikSHW14} y replicación \cite{FernandezMKP13}.

La planificación determinista \cite{DongTS07} se centra en la planificación según los recursos y estados del sistema \textsl{a priori} según alguna métrica \cite{XuCTS14}. Una métrica utilizada es la frecuencia de datos estimada en un nodo u operador \cite{Ganguly09}. Esta técnica se utiliza, por ejemplo, en \textsl{StreamIt} \cite{ThiesKA02}. Una de las limitaciones es que si bien realiza una predicción determinista de la frecuencia, no necesariamente es correcta a futuro, por lo que no se puede predecir las tasas de tráfico en el transcurso del procesamiento, sino sólo estimarlas al comienzo de la ejecución del sistema.

Otra estrategia está orientada a descartar eventos de un operador sobrecargado, de tal manera de no generar colas en el sistema. Esta estrategia que si bien no está implementada en el sistema por defecto de S4, puede habilitarse \cite{s4}. Otro ejemplo, es la trasmisión de vídeo \textsl{streaming}, donde se descartan los datos que son de baja calidad, para procesar en su mayoría información de alta calidad \cite{SheuC09}. Esta solución está pensada para disminuir la carga, perdiendo la exactitud de la información debido a la pérdida de datos. Por lo tanto existe una menor fiabilidad en el sistema en caso de realizar operaciones de transacción \cite{bookDistrSys}.

También se encuentra la migración, en el cual según el estado del sistema se migran los operadores de un nodo a otro. En \cite{XingZH05} se implementa   esta técnica, y si bien genera una menor carga en distintos nodos, produce un alto costo en la transferencia de los datos. Al realizar la transferencia de los datos, existe una menor tolerancia a fallos, a raíz de lo cual, se propone el uso de un búffer en el sistema, aumentando sus costos \cite{PittauACA07}.

Desde otra perspectiva, existen las técnicas de paralelización y replicación, las cuales se utilizan en caso de sobrepasar un umbral, el cual depende de la carga de un operador, nodo, entre otras variables. El primero consiste en paralelizar una tarea, la cual está determinada por un conjunto de operadores, en otro nodo físico \cite{IshiiS11}. En cambio, la replicación consiste en replicar un operador a nivel lógico del grafo \cite{MadsenTZ14}. Una de las características que existen en este tipo de soluciones es la elasticidad, que consiste en la capacidad de aumentar o disminuir la cantidad de operadores según la necesidad del sistema.

Una aplicación de la técnica de paralelización según el enfoque estático, es la paralelización de tareas de Storm \cite{stormtwitterdoc}, donde un conjunto de operadores realizan una tarea, indicado la cantidad de tareas que se desean ejecutar paralelamente en el sistema. Un ejemplo aplicado de esta técnica según el enfoque dińamico es StreamCloud \cite{GulisanoJPSV12}, que dada la cantidad de consultas que van llegando al sistema, se paralelizan las tareas existentes. Uno de los problemas que surge en estos casos son las operaciones con estado, como lo son los contadores o algoritmos de orden. La solución planteada es poseer un operador que realiza la tarea de \textsl{merge}, que consiste en recibir las salidas de las tareas paralelas, agrupando los datos y proporcionando una salida según lo realizado por cada uno de las operaciones \cite{GedikSHW14}.

Por otra parte, se usa la técnica de replicación en una aplicación diseñada por Fernández \cite{FernandezMKP13}. Ésta está enfocada en la replicación de operadores, la cual se activa si se detecta un cuello botella en el procesamiento de los datos. Para la detección, existe un monitor que está recibiendo la carga de cada uno de los procesos, y si es sobrepasado el umbral, debe realizar una petición de replicación al operador sobrecargado.